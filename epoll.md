# epoll

## epoll LT

高电平触发

1.EPOLLIN事件

内核socket接受缓冲区 为空 低电平

内核socket接受缓冲区 非空 高电平

2.EPOLLOUT事件

低电平->高电平 触发

高电平->低电平 触发

内核socket发送缓冲区 不满 高电平

内核socket发送缓冲区 为满 低电平

3.读缓冲不为空，触发读事件；写缓冲为空，触发写事件

## epoll ET

EPOLLIN事件，内核socket接受缓冲区从无->有（低电平->高电平）

EPOLLOUT事件，内核socket发送缓冲区从满->不满（低电平->高电平）
不可写->可写

### epoll
- 服务端LT 客户端LT (分析服务端:fd接收缓冲有数据,epoll_wait一直触发)。
- 服务端ET 客户端LT (分析服务端:fd接收缓冲有数据,epoll_wait触发1次，直到下次客户端发送数据，epoll_wait再次触发，所以服务端应该一次性读完)。接收缓冲区未满情况，?接受缓冲满的情况是什么
- 服务端LT 客户端LT (分析客户端:fd发送缓冲还有空间，还能写入，epoll_wait就会被不断被唤醒，直至发送端写完数据包，取消fd对EPOLLOUT事件的监听为止)。
- 服务端LT 客户端ET (在ET模式下，一旦IO准备就绪，我们需要一次性将要发送的数据包写完，如果写完，我们要取消fd对EPOLLOUT事件的监听，下次有新的数据要发送时，重新为fd在epoll实例中添加EPOLLOUT这个flag，那么epoll_wait才会被再次唤醒，让客户端进行写入。也就是说，在我们的发送缓存，不会被写满的情况下，每次为fd设置一次EPOLLOUT标志，epoll_wait只会被唤醒一次)。

在LT模式中，只要接收缓冲不为空，epoll_wait会不断被唤醒，每次唤醒时，我们不必一次将其读完。
在LT模式中，只要发送缓存未满，epoll_wait就会不断被唤醒，我们不必一次将要发送的数据包写完，或者将发送缓冲写满。
在ET模式中，接收缓存每收到一次数据包，只会唤醒epoll_wait一次，此时我们要将接收缓冲区内的信息一次读完，否则未读取的数据包就会残留在接收缓存中。
在ET模式中，每次为fd设置一次EPOLLOUT的flag，在发送缓冲不会被写满的情况下，epoll_wait只会被唤醒一次。如果我们将发送缓存写满，当它空出来的时候，我们不用再次设置EPOLLOUT到fd中，epoll_wait也会再次被唤醒。因此我们必须在epoll_wait唤醒的时候，一次将要发送的数据写完，或者将发送缓存写满，否则就会发生事件泄露。